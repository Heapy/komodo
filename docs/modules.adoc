Сегодня очевидно что любое приложение стоится из небольших, переиспользуемых частей. 

Это могут быть функции или классы.
Это могут модули вашего фреймворка, DI.
Это отдельные бибилиотеки которые вы подключаете в проект. 

Даже в случае Spring Framework/Spring Boot возможно нейкое понятие модулей, так:

Spring Context может строится из нескольких XML - модулей, нескольких Java Config каждый из которых отвечает за какой-нибудь слой приложения.
Spring Boot не имеет как такого понятия модуля, но его стартеры в какой-то мере можно считать модулями. Каждый стартер привносит в контекст какие-то бины, какую-то конфигурацию. Отвечает за определенную функциональность. И является переиспользуемым.

В целом чем обусловлена необходимость модулей, и какую задачу они решают в Komodo:

. Разделение приложения на слои: каждый слой (например Api, Service, Data) отвечает за определеную функциональность.
 Модули в данном случае позволяют протестировать слои относительно независимо.
 Например Data слой самый низкий в приложении и требует только JDBC модуль - значит в тесте только он будет загружен.
 Можно пойти дальше и автоматически мокировать в тестах зависимости из других модулей - TestBinder, Junit5 Extension?.

Абстрактные модули.

. Module : JdbcModule - в JdbcModule можно описать необходимые проперти которые конкретный модуль должен заправайдить.
. Загружать реализации абстрактных модулей через ServiceApi? Либо явно указывать, и Binder будет искать реализацию модуля. Т.е. модуль биндинг?
 bind.module(JdbcModule::class).to(HikaryJdbcModule::class) // in top level module
 bind.module(JdbcModule::class).toProvider(ServiceLoaderProvider::class) // in top level module
